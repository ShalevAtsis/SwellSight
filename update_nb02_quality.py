"""Update quality assessment cell to use DataQualityAssessor"""
import json
from pathlib import Path

notebook_path = Path("02_Data_Import_and_Preprocessing_Enhanced.ipynb")
with open(notebook_path, 'r', encoding='utf-8') as f:
    notebook = json.load(f)

# Find the quality assessment cell (cell 3, index 2)
# Replace inline quality assessment with DataQualityAssessor
quality_cell = [
    "# Image Quality Assessment using Production DataQualityAssessor\n",
    "print(\"üîç Performing comprehensive image quality assessment...\")\n",
    "\n",
    "if PRODUCTION_MODULES_AVAILABLE:\n",
    "    # Use production DataQualityAssessor\n",
    "    print(\"\\nüìä Using DataQualityAssessor from src.swellsight.evaluation.data_quality\")\n",
    "    \n",
    "    try:\n",
    "        # Initialize assessor with quality thresholds\n",
    "        assessor = DataQualityAssessor(\n",
    "            min_resolution=(640, 480),\n",
    "            max_resolution=(3840, 2160),\n",
    "            min_contrast_threshold=0.1,\n",
    "            min_sharpness_threshold=100.0,\n",
    "            min_ocean_coverage=0.3\n",
    "        )\n",
    "        \n",
    "        # Run comprehensive quality assessment\n",
    "        quality_report = assessor.assess_quality(REAL_IMAGES_PATH)\n",
    "        \n",
    "        # Display results\n",
    "        print(f\"\\n‚úÖ Quality assessment completed!\")\n",
    "        print(f\"   Overall Quality Score: {quality_report.overall_score:.2f}\")\n",
    "        print(f\"   Total images: {quality_report.dataset_statistics.total_images}\")\n",
    "        print(f\"   Valid images: {quality_report.dataset_statistics.total_images - quality_report.dataset_statistics.corrupted_count}\")\n",
    "        print(f\"   Corrupted images: {quality_report.dataset_statistics.corrupted_count}\")\n",
    "        \n",
    "        # Display quality issues\n",
    "        if quality_report.quality_issues:\n",
    "            print(f\"\\n‚ö†Ô∏è  Quality Issues Found: {len(quality_report.quality_issues)}\")\n",
    "            for issue in quality_report.quality_issues:\n",
    "                print(f\"   [{issue.severity.upper()}] {issue.issue_type}: {issue.description}\")\n",
    "                print(f\"      Affected: {issue.affected_count} images ({issue.percentage:.1f}%)\")\n",
    "        \n",
    "        # Display recommendations\n",
    "        if quality_report.recommendations:\n",
    "            print(f\"\\nüí° Recommendations:\")\n",
    "            for rec in quality_report.recommendations:\n",
    "                print(f\"   - {rec}\")\n",
    "        \n",
    "        # Store for later use\n",
    "        image_metadata = []\n",
    "        valid_images = []\n",
    "        invalid_images = []\n",
    "        \n",
    "    except Exception as e:\n",
    "        error_handler.handle_error(e, \"DataImport\", \"quality_assessment\")\n",
    "        print(f\"‚ùå Quality assessment failed: {e}\")\n",
    "        print(\"Falling back to basic validation...\")\n",
    "        PRODUCTION_MODULES_AVAILABLE = False\n",
    "\n",
    "if not PRODUCTION_MODULES_AVAILABLE:\n",
    "    # Fallback: Basic inline quality assessment\n",
    "    print(\"\\nüìä Using fallback inline quality assessment\")\n",
    "    from PIL import ImageStat\n",
    "    \n",
    "    image_metadata = []\n",
    "    valid_images = []\n",
    "    invalid_images = []\n",
    "    quality_stats = {\n",
    "        'total_size_mb': 0, 'resolutions': [], 'aspect_ratios': [],\n",
    "        'formats': {}, 'color_modes': {},\n",
    "        'brightness_scores': [], 'contrast_scores': []\n",
    "    }\n",
    "    \n",
    "    print(f\"\\nüìä Processing {len(image_paths)} images...\")\n",
    "    for image_path in tqdm(image_paths, desc=\"Analyzing images\"):\n",
    "        try:\n",
    "            with Image.open(image_path) as img:\n",
    "                width, height = img.size\n",
    "                format_name = img.format\n",
    "                mode = img.mode\n",
    "                file_size_mb = image_path.stat().st_size / (1024 * 1024)\n",
    "                stat = ImageStat.Stat(img)\n",
    "                brightness = sum(stat.mean) / len(stat.mean)\n",
    "                contrast = sum(stat.stddev) / len(stat.stddev)\n",
    "                aspect_ratio = width / height\n",
    "                \n",
    "                metadata = {\n",
    "                    'filename': image_path.name, 'path': str(image_path),\n",
    "                    'width': width, 'height': height,\n",
    "                    'resolution': f\"{width}x{height}\",\n",
    "                    'aspect_ratio': round(aspect_ratio, 3),\n",
    "                    'format': format_name, 'mode': mode,\n",
    "                    'file_size_mb': round(file_size_mb, 2),\n",
    "                    'brightness': round(brightness, 2),\n",
    "                    'contrast': round(contrast, 2),\n",
    "                    'valid': True, 'error': None\n",
    "                }\n",
    "                image_metadata.append(metadata)\n",
    "                valid_images.append(image_path)\n",
    "                quality_stats['total_size_mb'] += file_size_mb\n",
    "                quality_stats['resolutions'].append(f\"{width}x{height}\")\n",
    "                quality_stats['aspect_ratios'].append(aspect_ratio)\n",
    "                quality_stats['brightness_scores'].append(brightness)\n",
    "                quality_stats['contrast_scores'].append(contrast)\n",
    "                quality_stats['formats'][format_name] = quality_stats['formats'].get(format_name, 0) + 1\n",
    "                quality_stats['color_modes'][mode] = quality_stats['color_modes'].get(mode, 0) + 1\n",
    "        except Exception as e:\n",
    "            error_metadata = {\n",
    "                'filename': image_path.name, 'path': str(image_path),\n",
    "                'valid': False, 'error': str(e)\n",
    "            }\n",
    "            image_metadata.append(error_metadata)\n",
    "            invalid_images.append(image_path)\n",
    "            logger.warning(f\"Invalid image {image_path.name}: {e}\")\n",
    "    \n",
    "    print(f\"\\n‚úÖ Quality assessment completed!\")\n",
    "    print(f\"   Valid images: {len(valid_images)}\")\n",
    "    print(f\"   Invalid images: {len(invalid_images)}\")\n",
    "    print(f\"   Success rate: {len(valid_images)/len(image_paths)*100:.1f}%\")\n"
]

# Update cell 3 (index 2)
notebook['cells'][2]['source'] = quality_cell

with open("02_Data_Import_and_Preprocessing_Enhanced.ipynb", 'w') as f:
    json.dump(notebook, f, indent=2)
print("‚úÖ Quality assessment cell updated")
